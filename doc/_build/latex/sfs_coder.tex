% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{sfs\_coder Documentation}
\date{June 16, 2014}
\release{0}
\author{Lawrence Uricchio, Raul Torres, Ryan Hernandez}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Introduction}
\label{rstfiles/intro:introduction}\label{rstfiles/intro::doc}\label{rstfiles/intro:sfs-coder-documentation}
Forward simulation of DNA sequences is a powerful tool for analyzing the impact
of evolutionary forces on genetic variaiton.  Forward simulation can generate
sequence data under arbitrarily complex models that include nautral selection
as well as complex demography.  These models are difficult to handle
analytically, and other simulation frameworks such as the coalescent cannot
provide the same level of generality.

However, there remain some barriers to the adoption of population genetic
simulators for many members of the genetics community. Simulation software
tools can be daunting to master because of the vast number of input options
and the density of the output data.

sfs\_coder is a python based front end to the popular forward simulation
software SFS\_CODE.  It allows python coders to easily execute and analyze
simulations performed with SFS\_CODE.  For beginning users and coders, it
provides a number of useful cannonical models that are prepackaged and can be
accessed and analyzed with just a few lines of code.

For advanced users, sfs\_coder provides a tool set to access the power of
SFS\_CODE through a python based interface.  We encourage any interested users
to extend the code base that we provide and add any models that could be
useful for the community.

sfs\_coder is currently under developement and will be released in a few
months.  We don't expect these pages to get much traffic at the moment
but we have put them online for our development team. If you have stumbled
accross them and have any suggestions or would like to inquire about the
development feel free to email Lawrence (\href{mailto:uricchio@berkeley.edu}{uricchio@berkeley.edu}).

sfs\_coder will be free to use and distribute for personal or academic use.
We hope that you will find it useful.


\chapter{Installation}
\label{rstfiles/install:installation}\label{rstfiles/install::doc}
sfs\_coder does not require any installation of its own in order
to get its basic functionality.  Just download the source and alter the
PYTHONPATH variable on your machine so that python knows where to find the
modules (see the section on ``Importing'' below).

However, some methods within sfs\_coder require external software in order to
run.


\section{Required dependencies}
\label{rstfiles/install:required-dependencies}\begin{itemize}
\item {} 
\href{http://sfscode.sourceforge.net}{SFS\_CODE}

\end{itemize}

SFS\_CODE can be installed anywhere on the user's machine. The path
to the binary is supplied to sfs\_coder (see the section on
running SFS\_CODE through sfs\_coder).
\begin{itemize}
\item {} 
\href{https://www.python.org}{python} (\emph{2.7 or greater})

\end{itemize}


\section{Optional dependencies}
\label{rstfiles/install:optional-dependencies}\begin{itemize}
\item {} 
\href{https://code.google.com/p/mpmath/}{mpmath} (\emph{required for rescaled recurrent hitchhiking simulations})

\item {} 
\href{http://www.scipy.org/}{scipy} (\emph{required for rescaled recurrent hitchhiking simulations and some
methods in sfsplot})

\item {} 
\href{http://matplotlib.org/}{matplotlib} (\emph{required for plotting the output})

\end{itemize}


\section{Importing sfs\_coder's modules}
\label{rstfiles/install:importing-sfs-coder-s-modules}
Python uses the PYTHONPATH system variable to search for modules that are
imported.  Suppose we download sfs\_coder and store it in the directory
`\textasciitilde{}/sfs\_coder', and then we try to execute the following script called
`basic.py':

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{command}

\PYG{n}{com} \PYG{o}{=} \PYG{n}{SFSCommand}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

If the directory that contains command.py (`\textasciitilde{}/sfs\_coder/src' by default) is not
included in the PYTHONPATH variable, this will result in an error similar to
the following:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Traceback} \PYG{p}{(}\PYG{n}{most} \PYG{n}{recent} \PYG{n}{call} \PYG{n}{last}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{File} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{basic.py}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{13}\PYG{p}{,} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
    \PYG{k+kn}{import} \PYG{n+nn}{command}
\PYG{n+ne}{ImportError}\PYG{p}{:} \PYG{n}{No} \PYG{n}{module} \PYG{n}{named} \PYG{n}{command}
\end{Verbatim}

Python does not know where the command module is!  To fix this, we can add the
`\textasciitilde{}/sfs\_coder/src' directory to the PYTHONPATH variable in a couple different
ways.


\subsection{Adding the sfs\_coder source directory to PYTHONPATH in .bashrc}
\label{rstfiles/install:adding-the-sfs-coder-source-directory-to-pythonpath-in-bashrc}
If you execute your scripts at the command line with a bash shell, you can add
a line to your .bashrc file that will fix this problem and allow you to run the
above script.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{export }\PYG{n+nv}{PYTHONPATH}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}PYTHONPATH}:\PYGZti{}/sfs\PYGZus{}coder/src
\end{Verbatim}

The .bashrc file exists in your home directory and is read by bash every time
you open a new shell.  If a file called .bashrc doesn't exist in your home
directory you can create it.

Of course, if the path to your sfs\_coder `src' directory is different than
above you will need to provide the path to your copy of this directory.


\subsection{Adding the path to sfs\_coder's source directory within a python script}
\label{rstfiles/install:adding-the-path-to-sfs-coder-s-source-directory-within-a-python-script}
You can also add the path to sfs\_coder's `src' directory to any python script
if for any reason you don't want to modify your .bashrc as above.  Assuming
the same directory layout as the above example, we can use:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZti{}/sfs\PYGZus{}coder/src}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k+kn}{import} \PYG{n+nn}{command}

\PYG{n}{com} \PYG{o}{=} \PYG{n}{SFSCommand}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

This adds `\textasciitilde{}/sfs\_coder/src' to the PYTHONPATH variable within the script.
Note that this solution requires us to add this line of code to every python
script that imports something from sfs\_coder, whereas the first solution allows
us to import the modules just like any other python modules.


\chapter{Running SFS\_CODE simulations}
\label{rstfiles/execute::doc}\label{rstfiles/execute:running-sfs-code-simulations}

\section{The basic structure of an sfs\_coder script}
\label{rstfiles/execute:the-basic-structure-of-an-sfs-coder-script}
Running SFS\_CODE simulations with sfs\_coder requires only a few lines
of code.

First, we import the command module, initialize an SFSCommand object, and tell
the software where the sfs\_code binary is located.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{command}

\PYG{n}{com} \PYG{o}{=} \PYG{n}{command}\PYG{o}{.}\PYG{n}{SFSCommand}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{com}\PYG{o}{.}\PYG{n}{sfs\PYGZus{}code\PYGZus{}loc} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/path/to/sfs\PYGZus{}code}\PYG{l+s}{\PYGZsq{}}
\end{Verbatim}

Next, we need to build a command line.  Although this process is very
flexible (in fact we can build any command line that is accepted by SFS\_CODE),
we have prepackaged several models that may be of general interest.  For
example, to simulate the model of Gutenkunst (2009, \emph{PLoS Genetics}), we
call the following:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{com}\PYG{o}{.}\PYG{n}{gutenkunst}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{com}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

And that's it!  Of course, there are many more options that can be altered to
modify the parameters of the simulation, such as the ancestral population size.
Please see the ``scripts'' directory in the top level of sfs\_coder for more
complicated examples. Below, we include a slight modification of the above
script that demonstrates some basic functionality that may be useful to users,
as well as a few other examples.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{command}
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{from} \PYG{n+nn}{random} \PYG{k+kn}{import} \PYG{n}{randint}

\PYG{c}{\PYGZsh{} initialize an SFS\PYGZus{}CODE command, set the prefix of the output subdirectory}
\PYG{n}{com} \PYG{o}{=} \PYG{n}{command}\PYG{o}{.}\PYG{n}{SFSCommand}\PYG{p}{(}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{guten.N500}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} build the command line for the Gutenkunst model, specifying some parameters}
\PYG{n}{com}\PYG{o}{.}\PYG{n}{gutenkunst}\PYG{p}{(}\PYG{n}{N}\PYG{o}{=}\PYG{l+m+mi}{500}\PYG{p}{,}\PYG{n}{nsam}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{n}{nsim}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}

\PYG{c}{\PYGZsh{} set the location of the sfs\PYGZus{}code binary}
\PYG{n}{com}\PYG{o}{.}\PYG{n}{sfs\PYGZus{}code\PYGZus{}loc} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{expanduser}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZti{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
                       \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{path/to/sfs\PYGZus{}code}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} execute the command, supplying a random number}
\PYG{n}{com}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{n}{rand}\PYG{o}{=}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{100000}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}


\section{Examples}
\label{rstfiles/execute:examples}

\subsection{Adding selection}
\label{rstfiles/execute:adding-selection}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{command}
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{from} \PYG{n+nn}{random} \PYG{k+kn}{import} \PYG{n}{randint}

\PYG{c}{\PYGZsh{} initialize a new SFS\PYGZus{}CODE command}
\PYG{n}{com} \PYG{o}{=} \PYG{n}{command}\PYG{o}{.}\PYG{n}{SFSCommand}\PYG{p}{(}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{tennessen.N1000}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} build the command line for the tennessen model}
\PYG{c}{\PYGZsh{} a selection model is added with sel = sel=[\PYGZsq{}\PYGZhy{}W\PYGZsq{},\PYGZsq{}1\PYGZsq{},\PYGZsq{}5\PYGZsq{},\PYGZsq{}0\PYGZsq{},\PYGZsq{}1\PYGZsq{}]}
\PYG{c}{\PYGZsh{} this adds a type 1 selection model, with gamma =5,}
\PYG{c}{\PYGZsh{} and the probability of negative seleciton set to 1.}
\PYG{c}{\PYGZsh{} for more on selection models in SFS\PYGZus{}CODE, see the SFS\PYGZus{}CODE handbook}

\PYG{n}{com}\PYG{o}{.}\PYG{n}{three\PYGZus{}pop}\PYG{p}{(}\PYG{n}{N}\PYG{o}{=}\PYG{l+m+mi}{1000}\PYG{p}{,}\PYG{n}{nsam}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{nsim}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{n}{model}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{tennessen}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
              \PYG{n}{L}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}L}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{100}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{sel}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}W}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{5}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}

\PYG{c}{\PYGZsh{} set the location of sfs\PYGZus{}code}
\PYG{n}{com}\PYG{o}{.}\PYG{n}{sfs\PYGZus{}code\PYGZus{}loc} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{expanduser}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZti{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
                    \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{rotations/hernandez/software/sfs\PYGZus{}code/bin/sfs\PYGZus{}code}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} execute the command}
\PYG{n}{com}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{n}{rand}\PYG{o}{=}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{100000}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}


\subsection{Simulations with realistic genomic structure and demography}
\label{rstfiles/execute:simulations-with-realistic-genomic-structure-and-demography}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{command}
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{from} \PYG{n+nn}{random} \PYG{k+kn}{import} \PYG{n}{randint}

\PYG{c}{\PYGZsh{} initialize a new SFS\PYGZus{}CODE command}
\PYG{n}{com} \PYG{o}{=} \PYG{n}{command}\PYG{o}{.}\PYG{n}{SFSCommand}\PYG{p}{(}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{guten.lactase}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} build the command line for the gutenkunst model in the lactase region}
\PYG{n}{com}\PYG{o}{.}\PYG{n}{genomic}\PYG{p}{(}\PYG{n}{N}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{n}{model}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{gutenkunst}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{sel}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}

\PYG{c}{\PYGZsh{} set the location of sfs\PYGZus{}code}
\PYG{n}{com}\PYG{o}{.}\PYG{n}{sfs\PYGZus{}code\PYGZus{}loc} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{expanduser}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZti{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{rotations/hernandez/software/sfs\PYGZus{}code/bin/sfs\PYGZus{}code}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} execute the command}
\PYG{n}{com}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{n}{rand}\PYG{o}{=}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{100000}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}


\subsection{Using SGE}
\label{rstfiles/execute:using-sge}
sfs\_coder uses the sge\_task\_id system variable to number output files.
If you submit an sfs\_coder script to a cluster as an array job, it will take
care of all the work of numbering the output files for you.

For example, any of the above scripts can be sent to a cluster with the
following header:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{}!/usr/bin/python}
\PYG{c}{\PYGZsh{}\PYGZdl{} \PYGZhy{}e sim.div.log}
\PYG{c}{\PYGZsh{}\PYGZdl{} \PYGZhy{}o sim.div.log}
\PYG{c}{\PYGZsh{}\PYGZdl{} \PYGZhy{}S /usr/bin/python}
\PYG{c}{\PYGZsh{}\PYGZdl{} \PYGZhy{}cwd}
\PYG{c}{\PYGZsh{}\PYGZdl{} \PYGZhy{}r yes}
\PYG{c}{\PYGZsh{}\PYGZdl{} \PYGZhy{}l h\PYGZus{}rt=240:00:00}
\PYG{c}{\PYGZsh{}\PYGZdl{} \PYGZhy{}t 1\PYGZhy{}100}
\PYG{c}{\PYGZsh{}\PYGZdl{} \PYGZhy{}l arch=linux\PYGZhy{}x64}
\PYG{c}{\PYGZsh{}\PYGZdl{} \PYGZhy{}l mem\PYGZus{}free=1G}
\PYG{c}{\PYGZsh{}\PYGZdl{} \PYGZhy{}l netapp=1G}
\end{Verbatim}


\subsection{Simulations of phenotypes}
\label{rstfiles/execute:simulations-of-phenotypes}

\chapter{Analyzing the output}
\label{rstfiles/analyze:analyzing-the-output}\label{rstfiles/analyze::doc}
sfs\_code stores a great deal of information about each mutation or substitution
in a simulation, which can make it challenging to parse the output.  With
sfs\_coder, all the data is stored internally in the Mutation class, allowing
for flexible manipulation of the output.


\section{Opening and reading an output file}
\label{rstfiles/analyze:opening-and-reading-an-output-file}
Opening and reading files is simple.  Below is an example that reads in all
the data in an SFS\_CODE output file and caluclates \(\pi\) (the average
pairwise diversity) in the 0th locus in all sampled populations.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{readsfs}

\PYG{c}{\PYGZsh{} an sfs\PYGZus{}code output file that we will analyze}
\PYG{n}{f} \PYG{o}{=}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{c}{\PYGZsh{} initializing a data object and setting the file path}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{readsfs}\PYG{o}{.}\PYG{n}{SFSData}\PYG{p}{(}\PYG{n+nb}{file}\PYG{o}{=}\PYG{n}{f}\PYG{p}{)}

\PYG{c}{\PYGZsh{} getting all the data from the simulations in the file}
\PYG{n}{data}\PYG{o}{.}\PYG{n}{get\PYGZus{}sims}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} The simulations in the file are stored in the data.sims attribute}
\PYG{c}{\PYGZsh{} for each Simulation object in data.sims, we can calculate pi for}
\PYG{c}{\PYGZsh{} a set of loci}

\PYG{k}{for} \PYG{n}{sim} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{sims}\PYG{p}{:}

    \PYG{n}{pis} \PYG{o}{=} \PYG{n}{sim}\PYG{o}{.}\PYG{n}{calc\PYGZus{}pi}\PYG{p}{(}\PYG{n}{loci}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{c}{\PYGZsh{} array of pi values, indexed by population}
    \PYG{k}{print} \PYG{n}{pis}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}                \PYG{c}{\PYGZsh{} pis[0] is pi in the 0th population}
\end{Verbatim}


\chapter{Plotting}
\label{rstfiles/plot::doc}\label{rstfiles/plot:plotting}

\chapter{sfs\_coder Classes and methods}
\label{index:sfs-coder-classes-and-methods}

\section{contents of command.py}
\label{index:module-command}\label{index:contents-of-command-py}\index{command (module)}\index{Command (class in command)}

\begin{fulllineitems}
\phantomsection\label{index:command.Command}\pysigline{\strong{class }\code{command.}\bfcode{Command}}
This class stores information from parsed command lines
and provides the mechanics to call SFS\_CODE commands.
\index{execute() (command.Command method)}

\begin{fulllineitems}
\phantomsection\label{index:command.Command.execute}\pysiglinewithargsret{\bfcode{execute}}{\emph{rand=1}}{}
execute a simulation command
\begin{itemize}
\item {} 
Parameters:
\begin{itemize}
\item {} \begin{description}
\item[{\emph{rand=1} }] \leavevmode
a random integer. If the value is not reset by the user
then a new random number is rolled within self.execute.
This value is used as the random seed for SFS\_CODE.

\end{description}

\end{itemize}

\end{itemize}

\end{fulllineitems}


\end{fulllineitems}

\index{SFSCommand (class in command)}

\begin{fulllineitems}
\phantomsection\label{index:command.SFSCommand}\pysiglinewithargsret{\strong{class }\code{command.}\bfcode{SFSCommand}}{\emph{outdir='/Users/luricchio/projects/cluster\_backup/sfs\_coder/doc/sims'}, \emph{prefix='out'}, \emph{err='err'}}{}
This class is used to store, parse, and convert SFS\_CODE command lines.

Upon initialization, an object of the SFSCommand class sets the values
of many of its attributes to the SFS\_CODE defaults.
\begin{itemize}
\item {} 
Parameters:
\begin{itemize}
\item {} \begin{description}
\item[{\emph{outdir=os.path.join(os.getcwd(), `sims')} }] \leavevmode
A directory containing
subdirectories with sfs\_code simulations.

\end{description}

\item {} \begin{description}
\item[{\emph{prefix='out'} }] \leavevmode
The prefix of the out directory and the data files 
within the out directory.

\end{description}

\item {} \begin{description}
\item[{\emph{err='err'}}] \leavevmode
The name of the directory that contains all the stderr ouput from
calling sfs\_code.

\end{description}

\end{itemize}

\item {} 
Attributes:
\begin{itemize}
\item {} \begin{description}
\item[{\emph{self.com\_string='`}}] \leavevmode
the entire command stored as a single string.

\end{description}

\item {} \begin{description}
\item[{\emph{self.outdir= outdir}   }] \leavevmode
the parent directory of output directories for sets of SFS\_CODE 
simulations

\end{description}

\item {} \begin{description}
\item[{\emph{self.sfs\_code\_loc = `'}   }] \leavevmode
the location of the SFS\_CODE binary.

\end{description}

\item {} \begin{description}
\item[{\emph{self.N = 500}  }] \leavevmode
the number of individuals in the ancestral population.

\end{description}

\item {} \begin{description}
\item[{\emph{self.P = {[}2{]}}  }] \leavevmode
the ploidy of the individuals in each population.

\end{description}

\item {} \begin{description}
\item[{\emph{self.t = 0.001}}] \leavevmode
\(\theta = 4Nu = 0.001\).  This is the value of 
\(\theta\) in the ancestral population

\end{description}

\item {} \begin{description}
\item[{\emph{self.L = {[}5000{]}} }] \leavevmode
an array containing the length of each simulate locus.

\end{description}

\item {} \begin{description}
\item[{\emph{self.B = 5 self.p{[}0{]} self.N} }] \leavevmode
the length of the burn in (generations).

\end{description}

\item {} \begin{description}
\item[{\emph{self.prefix= prefix} }] \leavevmode
the prefix for the output file directory and each simulation file.

\end{description}

\item {} \begin{description}
\item[{\emph{self.r=0.0.} }] \leavevmode
\(\rho = 4Nr = 0.0\).  The value of \(\rho\) in the 
ancestral population.

\end{description}

\item {} \begin{description}
\item[{\emph{self.n\_pops=1} }] \leavevmode
number of populations.

\end{description}

\item {} \begin{description}
\item[{\emph{self.n\_iter=1} }] \leavevmode
number of simulations.

\end{description}

\item {} \begin{description}
\item[{\emph{self.line={[}{]}} }] \leavevmode
an array of strings, each of which is an argument
to SFS\_CODE.  This is the attribute that is used to execute SFS\_CODE
commands.

\end{description}

\end{itemize}

\end{itemize}
\index{add\_event() (command.SFSCommand method)}

\begin{fulllineitems}
\phantomsection\label{index:command.SFSCommand.add_event}\pysiglinewithargsret{\bfcode{add\_event}}{\emph{event}}{}
add an event to a command line.
\begin{itemize}
\item {} 
Parameters:
\begin{itemize}
\item {} \begin{description}
\item[{\emph{event} }] \leavevmode
an array of strings corresponding to the event.

e.g., adding a mutation at locus 0 at time 0 with

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{event} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}\PYGZhy{}mutation}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{L}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{0}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

\end{description}

\end{itemize}

\end{itemize}

\end{fulllineitems}

\index{build\_RHH() (command.SFSCommand method)}

\begin{fulllineitems}
\phantomsection\label{index:command.SFSCommand.build_RHH}\pysiglinewithargsret{\bfcode{build\_RHH}}{\emph{alpha=1000.0}, \emph{N0=5000.0}, \emph{rho0=0.001}, \emph{lam0=1e-10}, \emph{delta=0.01}, \emph{L0=-1}, \emph{L1=100000.0}, \emph{loop\_max=10}, \emph{L\_neut=1000.0}, \emph{theta\_neut=0.001}, \emph{minpop=100}, \emph{recomb\_dir='recombfiles'}, \emph{outdir='sims'}, \emph{TE=2}, \emph{r\_within=True}, \emph{neg\_sel\_rate=0.0}, \emph{alpha\_neg=5}, \emph{additive=1}, \emph{Lextend=1}, \emph{mutation=}\optional{}, \emph{bottle=}\optional{}, \emph{expansion=}\optional{}, \emph{nreps=10}, \emph{Boyko=False}, \emph{Lmult=False}, \emph{lmultnum=50}, \emph{Torg=False}, \emph{non\_coding=True}}{}
A method to build a recurrent hitchhiking command line using the 
method of Uricchio \& Hernandez (2014, \emph{Genetics}).
\begin{itemize}
\item {} 
Dependencies:
\begin{itemize}
\item {} 
scipy

\item {} 
mpmath

\end{itemize}

\item {} 
Parameters
\begin{itemize}
\item {} \begin{description}
\item[{\emph{alpha = 1000} }] \leavevmode
\(\alpha = 2Ns\), the ancestral population 
scaled strength of selection.  Note that demographic events 
can change N, and hence they also changle alpha.

\end{description}

\item {} \begin{description}
\item[{\emph{N0 = 5000} }] \leavevmode
the ancestral population size

\end{description}

\item {} \begin{description}
\item[{\emph{rho0 = 0.001} }] \leavevmode
the population scaled recombination coefficient
in the ancestral population.

\end{description}

\item {} \begin{description}
\item[{\emph{lam0 = 10*}-10 }] \leavevmode
the rate of positive substitutions per generation
per site in the population.

\end{description}

\item {} \begin{description}
\item[{\emph{delta = 0.01} }] \leavevmode
a single parameter that encapsulates both delta 
parameters from Uricchio \& Hernandez (Genetics, 2014).
Smaller values of delta result in dynamics that are a better
match for the original population of size N0, but are more 
computationally expensive.  We do not recommend using values
of delta greater than 0.1.  For more information please see the
paper referenced above.

\end{description}

\item {} \begin{description}
\item[{\emph{L0 = -1} }] \leavevmode
the length of the flanking sequence on each side of the
neutral locus. If L0 is not reset from it's default value, 
it is automatically set to L0 = s0/r0, where s0 and r0 are 
alpha/2N0 and rho/4N0, respectively.

\end{description}

\item {} \begin{description}
\item[{\emph{theta\_neut = 0.001} }] \leavevmode
the neutral value of theta.

\end{description}

\item {} \begin{description}
\item[{\emph{TE=2}}] \leavevmode
the ending time of the simulation in units of 
2*N0*self.P{[}0{]} generations.

\end{description}

\item {} \begin{description}
\item[{\emph{r\_within=False}}] \leavevmode
Currently only works with this option set to False, 
but in the future will allow for recombination within the 
neutral locus.

\end{description}

\end{itemize}

\end{itemize}

\end{fulllineitems}

\index{genomic() (command.SFSCommand method)}

\begin{fulllineitems}
\phantomsection\label{index:command.SFSCommand.genomic}\pysiglinewithargsret{\bfcode{genomic}}{\emph{basedir='../src/../src/req', indir='/Users/luricchio/projects/cluster\_backup/sfs\_coder/doc/input\_files', datafile='hg19\_gencode.v14.gtf.gz', phast\_file='hg19\_phastCons\_mammal.wig.gz', dense\_dist=5000, begpos=134545415, endpos=138594750, db=-1, chr=2, de=-1, withseq=0, fafile='`, N=2000, mutation={[}{]}, sel=True, model='`, t=0.001, rho=0.001, nsim=10, nsam={[}20{]}}}{}
A method for running simulations of genomic elements using realistic
genome structure and demographic models.  The demographic models of 
Gutenkunst (2009, \emph{PLoS Genetics}), Gravle (2011, \emph{PNAS}), Tennessenn
(2012,*Science*), and the standard neutral model are included.

The default data sources and options are all
human-centric, but in principle these methods could be used to simulate
sequences from any population for which the relevant data sources are 
available (recombination map, conserved elements, exon positions).

This function calls a number of perl scripts, originally 
implemented by Ryan Hernandez, to build the input to SFS\_CODE.  These
perl scripts are bundled with sfs\_coder in the directory src/req
\begin{itemize}
\item {} 
Parameters:
\begin{itemize}
\item {} \begin{description}
\item[{\emph{basedir=os.path.join(os.path.dirname(\_\_file\_\_),'../src/req')}}] \leavevmode
the directory where all the datasources and perl for this method
are located.  You shouldn't have to change this unless you're
moving around the source files relative to each other.

\end{description}

\item {} \begin{description}
\item[{\emph{outdir=os.path.join(os.getcwd(),'input\_files')}}] \leavevmode
the directory where the sfs\_code annotation files will be 
written

\end{description}

\item {} \begin{description}
\item[{\emph{chr=2}}] \leavevmode
chromosome number to query

\end{description}

\item {} \begin{description}
\item[{\emph{begpos=134545415}}] \leavevmode
genomic coordinate of the beginning of the simulated sequence

\end{description}

\item {} \begin{description}
\item[{\emph{endpos=138594750}}] \leavevmode
genomic coordinate of the end of the simulated sequence

\end{description}

\item {} \begin{description}
\item[{\emph{db=begpos}}] \leavevmode
genomic coordinate of the region in which to include dense 
neutral sequences.  Neutral sites within this region will be 
simulated if they are within a specified distance of one
of the simulated genomic elements (given by \emph{dense\_dist})

\end{description}

\item {} \begin{description}
\item[{\emph{de=begpos}}] \leavevmode
genomic coordinate of the end of the dense neutral region

\end{description}

\item {} \begin{description}
\item[{\emph{dense\_dist=5000}}] \leavevmode
The amount of neutral sequence to pad onto the end of each 
conserved element or exon.  For example, if two adjaacent 
conserved elemets are 20,000 base pairs apart, and the 
dense\_dist=5,000, then 5,000 base pairs are padded onto the 
end of each of the conserved elements and the middle 10,000
base pairs are not simulated.

To include no neutral sequence, use dense\_dist = 0.

To include every neutral base pair in the region, use 
dense\_dist=-1 (potentially very computationally expensive
for large regions!)

\end{description}

\item {} \begin{description}
\item[{\emph{sel=True}}] \leavevmode
If true, draw selection coefficients from a gamma distribution 
of selection coefficients for conserved elements and coding
regions.  These distributions are taken from Boyko et al 
(coding, 2008, \emph{PLoS Genetics}) and Torgerson et al (conserved 
non-coding, 2009, \emph{PLoS Genetics}).

\end{description}

\end{itemize}

\end{itemize}

\end{fulllineitems}

\index{gutenkunst() (command.SFSCommand method)}

\begin{fulllineitems}
\phantomsection\label{index:command.SFSCommand.gutenkunst}\pysiglinewithargsret{\bfcode{gutenkunst}}{\emph{add\_on=False, nsim=1, N=10000, non\_coding=False, recombfile='`, nsam={[}100{]}, mutation={[}{]}, t=0.001, rho=0.001, loci={[}{]}, sel={[}{]}, L={[}{]}}}{}
A method that adds the Gutenkunst (2009, \emph{PLoS Genetics}) model to
an SFS\_CODE command line.

\end{fulllineitems}

\index{parse\_string() (command.SFSCommand method)}

\begin{fulllineitems}
\phantomsection\label{index:command.SFSCommand.parse_string}\pysiglinewithargsret{\bfcode{parse\_string}}{}{}
A method to parse SFS\_CODE command lines.  By default, every switch
is stored as an array with the exception of certain special cases that
are stored as dictionaries.

Note, \textbf{only the short form of SFS\_CODE options are currently fully 
supported!}  For example, \emph{-t 0.002} is supported but \emph{--theta 0.002}
is not. Hence, if you run SFS\_CODE with the long forms or wish to 
analyze code that used the long form to run, you may have issues.

\end{fulllineitems}

\index{three\_pop() (command.SFSCommand method)}

\begin{fulllineitems}
\phantomsection\label{index:command.SFSCommand.three_pop}\pysiglinewithargsret{\bfcode{three\_pop}}{\emph{add\_on=False, nsim=1, N=10000, non\_coding=False, recombfile='`, nsam={[}100, 100, 100{]}, mutation={[}{]}, t=0.001, rho=0.001, loci={[}{]}, sel={[}{]}, L={[}{]}, t\_end=0.60274, t\_expand\_p0=0, expand\_p0=1.68493, t\_split\_p0\_p1=0.219178, t\_split\_p1\_p2=0.544658, bottle\_p1\_0=0.170732, bottle\_p1\_1=0.47619, bottle\_p2=0.242857, growth\_p1=58.4, growth\_p2=80.3, mig\_p0\_p1=6.15, mig\_p1\_p0=0.5, mig\_all={[}0.738, 0.4674, 0.06, 0.192, 0.01938, 0.09792{]}, t\_super=0.391465, model='guten'}}{}
A general three population model with growth events.
Inspired by Gutenkunst et al (2009, \emph{PLoS Genetics})
and Gravel et al (2011, \emph{PNAS}).  For a pictorial 
representation see Figure 3A of the Gutenkunst paper.

The default parameters are set to Gutenkunst et al.
The maximum likelihood estimates of Gravel et al
and Tennessen et al (2012, \emph{Science}) are also 
included.

Use model='gravel', model='tennessen' or model='guten'
to explicitly choose one of the models.

The user can specify the model parameters as desired.
To use a user specified model, simply use model = `'.
Any unspecified parameters are set by default to the 
parameters of the Gutenkunst model.

\end{fulllineitems}


\end{fulllineitems}



\section{contents of sfs.py}
\label{index:contents-of-sfs-py}\label{index:module-sfs}\index{sfs (module)}\index{Mutation (class in sfs)}

\begin{fulllineitems}
\phantomsection\label{index:sfs.Mutation}\pysigline{\strong{class }\code{sfs.}\bfcode{Mutation}}
a class to store the data associated with a variant in an 
SFS\_CODE output file.  Note, both mutations and substitutions
are stored as instances of this class.
\begin{itemize}
\item {} 
Attributes:
\begin{itemize}
\item {} \begin{description}
\item[{\emph{self.locus=-1}}] \leavevmode
The locus number of the variant

\end{description}

\item {} \begin{description}
\item[{\emph{self.AXY='?'} }] \leavevmode
`A' for autosomal, `X' or `Y' for the corresponding sex
chromosomes

\end{description}

\item {} \begin{description}
\item[{\emph{self.pos=-1}}] \leavevmode
The position within the locus.  Note that the positions
within each locus start from 0.

\end{description}

\item {} \begin{description}
\item[{\emph{self.t\_init=\{\}} }] \leavevmode
A dictionary, keyed by population number, and storing 
the time that the variant arose

\end{description}

\item {} \begin{description}
\item[{\emph{self.t\_fix=\{\}}}] \leavevmode
A dictionary, keyed by population number, and storing 
the time that the variant fixed within the population.
If the variant is segregating, the time stored is the
time of sampling.

\end{description}

\item {} \begin{description}
\item[{\emph{self.tri\_nuc='NNN'}}] \leavevmode
The ancestral trinucleotide (the middle base is the 
mutated base, so this is not necessarily a codon!)

\end{description}

\item {} \begin{description}
\item[{\emph{self.deriv\_n='N'}}] \leavevmode
The derived nucleotide

\end{description}

\item {} \begin{description}
\item[{\emph{self.non\_or\_syn='?'}}] \leavevmode
Is the mutation synonymous (0) or nonsynonymous (1).
0 also is used to indicate non-coding.

\end{description}

\item {} \begin{description}
\item[{\emph{self.ancest='?'}}] \leavevmode
Ancestral amino acid

\end{description}

\item {} \begin{description}
\item[{\emph{self.deriv\_aa='?'}}] \leavevmode
Derived amino acid

\end{description}

\item {} \begin{description}
\item[{\emph{self.fit='?'}}] \leavevmode
fitness effect of the mutation (0 for neutral)

\end{description}

\item {} \begin{description}
\item[{\emph{self.chrs = defaultdict(dict)}}] \leavevmode
A dictionary of dictionaries that is keyed by population
and chromosome number.

E.g., if the derived allele is present on chromosome 11 in
population 2, then

self.chrs{[}2{]}{[}11{]} = True

\end{description}

\item {} 
\emph{self.pops\_numchr = \{\}}
\begin{quote}

A dictionary that stores the number of chromosomes that
carry the derived allele in each population.
\end{quote}

\end{itemize}

\end{itemize}

\end{fulllineitems}

\index{SFSData (class in sfs)}

\begin{fulllineitems}
\phantomsection\label{index:sfs.SFSData}\pysiglinewithargsret{\strong{class }\code{sfs.}\bfcode{SFSData}}{\emph{file='`}}{}
A class that handles the basic parsing of sfs\_code output file
data.
\begin{itemize}
\item {} 
Parameters:
\begin{itemize}
\item {} \begin{description}
\item[{\emph{file= `'}}] \leavevmode
the path to the file that is to be read.

\end{description}

\end{itemize}

\item {} 
Attributes:
\begin{itemize}
\item {} \begin{description}
\item[{\emph{self.file = file}}] \leavevmode
the path to the file that is to be read.

\end{description}

\item {} \begin{description}
\item[{\emph{sims = {[}{]}}}] \leavevmode
an array of sfs.Simulation objects.

\end{description}

\end{itemize}

\end{itemize}
\index{get\_sims() (sfs.SFSData method)}

\begin{fulllineitems}
\phantomsection\label{index:sfs.SFSData.get_sims}\pysiglinewithargsret{\bfcode{get\_sims}}{}{}
A method that reads sfs\_code output files and stores all the data in
sfs.Simulation objects.

\end{fulllineitems}


\end{fulllineitems}

\index{Simulation (class in sfs)}

\begin{fulllineitems}
\phantomsection\label{index:sfs.Simulation}\pysigline{\strong{class }\code{sfs.}\bfcode{Simulation}}
A class to store the data from SFS\_CODE simulations.
\begin{itemize}
\item {} 
Attributes:
\begin{itemize}
\item {} 
\emph{self.command = command.SFSCommand()}

\item {} 
\emph{self.data = `'}

\item {} 
\emph{self.loci = defaultdict(lambda: defaultdict(list))}
\begin{quote}

A dictionary of dictionaries indexed by locus and position.
Each dictionary of dictionaries is a list of Mutation
objects that occur at the corresponding locus and position.

e.g., self.loci{[}0{]}{[}0{]} is a list of Mutation objects that
occur at the first position in the first locus.

Note that these keys will only exist in self.loci if there
were mutations at this particular point in the sequence
in the sample from the simulation.
\end{quote}

\item {} 
\emph{self.muts = {[}{]}}
\begin{quote}

A list of all the Mutation objects in the simulation.
\end{quote}

\end{itemize}

\end{itemize}
\index{calc\_S() (sfs.Simulation method)}

\begin{fulllineitems}
\phantomsection\label{index:sfs.Simulation.calc_S}\pysiglinewithargsret{\bfcode{calc\_S}}{\emph{multi\_skip=True}, \emph{loci=}\optional{}, \emph{pop=0}}{}
calculate the number of segretating sites within all
populations.
\begin{itemize}
\item {} 
Parameters:
\begin{itemize}
\item {} \begin{description}
\item[{\emph{multi\_skip = True}}] \leavevmode
skip sites that are more than biallelic if True

\end{description}

\item {} \begin{description}
\item[{\emph{loci = {[}{]}}}] \leavevmode
A list of loci over which to calculate the number of segregating
sites.  Uses all loci if this is left blank.

\end{description}

\end{itemize}

\end{itemize}

\end{fulllineitems}

\index{calc\_fit() (sfs.Simulation method)}

\begin{fulllineitems}
\phantomsection\label{index:sfs.Simulation.calc_fit}\pysiglinewithargsret{\bfcode{calc\_fit}}{\emph{pop=0}}{}
calculate the fitness of the sampled chromosomes
within a population.
\begin{itemize}
\item {} 
Parameters:
\begin{itemize}
\item {} \begin{description}
\item[{\emph{pop=0} }] \leavevmode
population number

\end{description}

\end{itemize}

\end{itemize}

\end{fulllineitems}

\index{calc\_pi() (sfs.Simulation method)}

\begin{fulllineitems}
\phantomsection\label{index:sfs.Simulation.calc_pi}\pysiglinewithargsret{\bfcode{calc\_pi}}{\emph{multi\_skip=True}, \emph{loci=}\optional{}}{}
calculate the mean pairwise diversity per site
bewteen pairs of sequences across a set of loci.
If the loci parameter is left undefined by the
user, then this method calculates \(\pi\) 
over all loci in the simulation.
\begin{itemize}
\item {} 
Parameters:
\begin{itemize}
\item {} 
\emph{multi\_skip=True}
\begin{quote}

If True, skip loci that are multiallelic.
Otherwise lump all the derived alleles together.
\end{quote}

\item {} 
\emph{loci={[}{]}}
\begin{quote}

An array of loci over which to calculate 
\(\pi\).  If left blank, all loci
are used in the calculation.
\end{quote}

\end{itemize}

\item {} 
Return value: An array of values of \(\pi\)
values indexed by population number.

\end{itemize}

\end{fulllineitems}

\index{calc\_pi\_by\_locus() (sfs.Simulation method)}

\begin{fulllineitems}
\phantomsection\label{index:sfs.Simulation.calc_pi_by_locus}\pysiglinewithargsret{\bfcode{calc\_pi\_by\_locus}}{}{}
calculate the value of \(\pi\) independently for each locus.
\begin{itemize}
\item {} 
Return value: An array of arrays of pi values, indexed by 
population and then locus number.

e.g., if the return value is stored in the variable pi, 
pi{[}0{]}{[}1{]} is the value of \(\pi\) in population 0 at locus 1.

\end{itemize}

\end{fulllineitems}

\index{get\_sfs() (sfs.Simulation method)}

\begin{fulllineitems}
\phantomsection\label{index:sfs.Simulation.get_sfs}\pysiglinewithargsret{\bfcode{get\_sfs}}{\emph{pop=0}, \emph{NS=True}, \emph{SYN=True}}{}
compute the site frequency specutrum for a population
\begin{itemize}
\item {} 
Parameters:
\begin{itemize}
\item {} \begin{description}
\item[{\emph{pop=0}}] \leavevmode
population number

\end{description}

\end{itemize}

\end{itemize}

\end{fulllineitems}


\end{fulllineitems}



\section{contents of sfsplot.py}
\label{index:contents-of-sfsplot-py}\label{index:module-sfsplot}\index{sfsplot (module)}

\section{contents of ms.py}
\label{index:contents-of-ms-py}\label{index:module-ms}\index{ms (module)}

\chapter{indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{c}
\item {\texttt{command}}, \pageref{index:module-command}
\indexspace
\bigletter{m}
\item {\texttt{ms}}, \pageref{index:module-ms}
\indexspace
\bigletter{s}
\item {\texttt{sfs}}, \pageref{index:module-sfs}
\item {\texttt{sfsplot}}, \pageref{index:module-sfsplot}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
